import ngat.phase2.*;
import ngat.astrometry.*;
import ngat.message.base.*;
import ngat.message.ISS_INST.*;
import ngat.net.*;
import ngat.fits.*;
import ngat.util.*;

import java.io.*;
import java.text.*;
import java.util.*;

/**
 * Perform instrument actions: CONFIG, EXPOSE, ACQUIRE, TWILIGHT_FLAT,
 * ABORT,...etc All instruments use this specific class and it is not very
 * particular about distinguishing between available command sets for different
 * instruments.
 * If each instrument were to be represented differently the mechanism would be to
 * have InstrumentRequestHandlerfactory return a different instrument-specific handler
 * based on the instrument.
 */
public class InstrumentControl {

	public static final SimpleDateFormat fdf = new SimpleDateFormat("yyyyMMdd");

	static final String[] ratlfilt = new String[] { "clear", "SDSS-I",
			"SDSS-Z", "SDSS-R", "H-Alpha-100" };
	static final String[] ratufilt = new String[] { "clear", "SDSS-G",
			"SDSS-U", "Bessell-B", "Bessell-V" };

	/** Server. */
	private SocketServer icsServer;

	/** ISS host. */
	private String issHost;

	/** ISS port. */
	private int issPort;

	/** Fold mirror port required. */
	private int mirrorPort;

	/** Instrument name. */
	private String name;

	/** Prefix for filename. */
	private String filePrefix;

	/** True if the instrument has arms. */
	private boolean hasArms;

	/** True if we can send DP ACKs. */
	private boolean sendDpAcks = false;

	/** Instrument status. */
	private Hashtable status;

	// TODO Seeing, photom etc should be generated by a seperate DPRT simulator.
	/** Average seeing. */
	private double avSee;

	/** STDEV seeing. */
	private double deltaSee;

	// Variables to keep track of generated filenames
	/** Count multruns. */
	int im = 0;

	/** Count acquires. */
	int iac = 0;

	/** Count flats. */
	int ilf = 0;

	public InstrumentControl(String name) {
		this.name = name;
		icsServer = new SocketServer(name);

	}

	public void startServer(int port) throws Exception {
		icsServer.bind(port);
		icsServer.setRequestHandlerFactory(new InstrumentRequestHandlerFactory());
		icsServer.setProtocolImplFactory(JMSMA_ProtocolImplFactory.getInstance());
		icsServer.start();
	}

	public static void main(String args[]) {

		try {

			ConfigurationProperties cfg = CommandTokenizer.use("--")
					.parse(args);

			String name = cfg.getProperty("name", "CCD");
			int port = cfg.getIntValue("port");

			String issHost = cfg.getProperty("iss-host", "localhost");

			int issPort = cfg.getIntValue("iss-port");

			double ms = cfg.getDoubleValue("mean-seeing", 0.8);
			double ds = cfg.getDoubleValue("std-seeing", 0.4);

			int mirrorPort = cfg.getIntValue("mirror-port");

			String prefix = cfg.getProperty("prefix", "any");

			boolean arms = (cfg.getProperty("arms") != null);

			boolean sendDpAcks = (cfg.getProperty("dpacks") != null);

			InstrumentControl ics = new InstrumentControl(name);
			ics.setIssHost(issHost);
			ics.setIssPort(issPort);
			ics.setAvSeeing(ms);
			ics.setDeltaSeeing(ds);
			ics.startServer(port);
			ics.setMirrorPort(mirrorPort);
			ics.setFilePrefix(prefix);
			ics.setHasArms(arms);
			ics.setSendDpAcks(sendDpAcks);

		} catch (Exception e) {
			e.printStackTrace();
			return;
		}
	}

	public void setFilePrefix(String prefix) {
		this.filePrefix = prefix;
	}

	public void setHasArms(boolean arms) {
		this.hasArms = arms;
	}

	public void setIssHost(String h) {
		this.issHost = h;
	}

	public void setIssPort(int p) {
		this.issPort = p;
	}

	public void setAvSeeing(double a) {
		this.avSee = a;
	}

	public void setDeltaSeeing(double d) {
		this.deltaSee = d;
	}

	public void setMirrorPort(int p) {
		this.mirrorPort = p;
	}

	public void setSendDpAcks(boolean s) {
		this.sendDpAcks = sendDpAcks;
	}

	class InstrumentRequestHandlerFactory implements RequestHandlerFactory {

		InstrumentRequestHandlerFactory() {
		}

		public RequestHandler createHandler(ProtocolImpl implementor,
				Object request) {

			// Deal with undefined and illegal args.
			if ((implementor == null)
					|| !(implementor instanceof JMSMA_ProtocolServerImpl))
				return null;
			if ((request == null) || !(request instanceof COMMAND))
				return null;

			// Cast to correct subclass.
			COMMAND command = (COMMAND) request;

			InstrumentRequestHandler impl = new InstrumentRequestHandler(
					(JMSMA_ProtocolServerImpl) implementor, (COMMAND) request);
			return impl;
			
			/* FUTURE IMPLEMENTATION
			 * 
			 * if (name.equals("IO:O")
			 *  return new IooHandler(...);
			 * else if (name.equals("RINGO3")
			 *  return new Ringo3Handler(...)
			 * else .....
			 */
			
			
		}

	}

	class InstrumentRequestHandler implements RequestHandler {

		JMSMA_ProtocolServerImpl implementor;
		COMMAND request;

		InstrumentRequestHandler(JMSMA_ProtocolServerImpl implementor,
				COMMAND request) {
			this.implementor = implementor;
			this.request = request;
		}

		/** Implementors should handle their request appropriately. */
		public void handleRequest() {

			ACK ack = new ACK("");
			ack.setTimeToComplete(60000);
			implementor.sendAck(ack);

			COMMAND_DONE reply;

			System.err.println("ICS: " + request);

			if (request instanceof CONFIG) {
				System.err.println("Config Class: "
						+ ((CONFIG) request).getConfig());

				InstrumentConfig iconf = ((CONFIG) request).getConfig();
				if (iconf instanceof CCDConfig && name.equals("RATCAM")) {

					String ufilt = ((CCDConfig) iconf).getUpperFilterWheel();
					String lfilt = ((CCDConfig) iconf).getLowerFilterWheel();

					boolean fail1 = true;
					for (int ik = 0; ik < ratlfilt.length; ik++) {
						if (lfilt.equals(ratlfilt[ik]))
							fail1 = false;
					}
					boolean fail2 = true;
					for (int ik = 0; ik < ratufilt.length; ik++) {
						if (ufilt.equals(ratufilt[ik]))
							fail2 = false;
					}

					if (fail1 || fail2) {
						CONFIG_DONE done = new CONFIG_DONE("");
						done.setErrorNum(100302);
						done.setErrorString("Filter mismatch: Lower: " + lfilt
								+ (fail1 ? " fail" : " ok") + "Upper: " + ufilt
								+ (fail2 ? " fail" : " ok"));
						done.setSuccessful(false);
						if (implementor != null)
							implementor.sendDone(done);
						return;

					}

				}

				ngat.message.ISS_INST.OFFSET_FOCUS df = new ngat.message.ISS_INST.OFFSET_FOCUS(
						request.getId());
				df.setFocusOffset((float) (Math.random() * 1.0 - 0.5));
				COMMAND_DONE dfdone = sendIssCommand(df, 40000L);
				if (!(dfdone instanceof ngat.message.ISS_INST.OFFSET_FOCUS_DONE)) {
					if (implementor != null)
						implementor.sendDone(dfdone);
					return;
				}

				if (!dfdone.getSuccessful()) {
					CONFIG_DONE done = new CONFIG_DONE("");
					done.setErrorNum(100301);
					done.setErrorString("The offset-focus failed due to: "
							+ dfdone.getErrorString());
					done.setSuccessful(false);
					if (implementor != null)
						implementor.sendDone(done);
					return;
				}

				try {
					Thread.sleep(5000L);
				} catch (Exception e) {
				}

				CONFIG_DONE done = new CONFIG_DONE("");
				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof ACQUIRE) {
				iac++;

				String datestr = fdf.format(new Date());

				ACQUIRE_DP_ACK adack = new ACQUIRE_DP_ACK("");
				adack.setTimeToComplete(120000);
				adack.setFilename("/icc/tmp/" + filePrefix + "_q_" + datestr
						+ "_" + (iac) + "_1_1_0.fits");
				implementor.sendAck(adack);

				ACQUIRE_DONE done = new ACQUIRE_DONE("");
				reply = done;
				reply.setSuccessful(true);

				try {
					Thread.sleep(10000L);
				} catch (Exception e) {
				}

			} else if (request instanceof REBOOT) {
				iac++;

				int level = ((REBOOT) request).getLevel();

				ACK adack = new ACK("");
				adack.setTimeToComplete(20000);
				implementor.sendAck(adack);

				REBOOT_DONE done = new REBOOT_DONE("");
				reply = done;
				reply.setSuccessful(true);

				try {
					Thread.sleep(10000L);
				} catch (Exception e) {
				}

				System.err.println("Rebooting at level: " + level);

			} else if (request instanceof LAMPFLAT) {
				ilf++;

				String datestr = fdf.format(new Date());

				// Send a MoveFold stow
				ack = new ACK("");
				ack.setTimeToComplete(60000);
				implementor.sendAck(ack);

				ngat.message.ISS_INST.MOVE_FOLD mf = new ngat.message.ISS_INST.MOVE_FOLD(
						request.getId());
				mf.setMirror_position(0);
				COMMAND_DONE mfdone = sendIssCommand(mf, 40000L);
				if (!(mfdone instanceof ngat.message.ISS_INST.MOVE_FOLD_DONE)) {
					if (implementor != null)
						implementor.sendDone(mfdone);
					return;
				}

				if (!mfdone.getSuccessful()) {
					MULTRUN_DONE done = new MULTRUN_DONE("");
					done.setErrorNum(100301);
					done.setErrorString("The move fold failed due to: "
							+ mfdone.getErrorString());
					done.setSuccessful(false);
					if (implementor != null)
						implementor.sendDone(done);
					return;
				}

				try {
					Thread.sleep(10000L);
				} catch (Exception e) {
				}

				FILENAME_ACK fack = new FILENAME_ACK("");
				fack.setTimeToComplete(10000);
				fack.setFilename("/icc/tmp/" + filePrefix + "_l_" + datestr
						+ "_" + (ilf) + "_1_1_0.fits");
				implementor.sendAck(fack);

				try {
					Thread.sleep(5000L);
				} catch (Exception e) {
				}

				FILENAME_ACK fpack = new FILENAME_ACK("");
				fpack.setTimeToComplete(10000);
				fpack.setFilename("/icc/tmp/" + filePrefix + "_l_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");
				implementor.sendAck(fpack);

				try {
					Thread.sleep(5000L);
				} catch (Exception e) {
				}

				LAMPFLAT_DONE done = new LAMPFLAT_DONE("");
				done.setFilename("icc/tmp/" + filePrefix + "+l_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");

				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof ARC) {
				ilf++;

				String datestr = fdf.format(new Date());

				// Send a MoveFold stow
				ack = new ACK("");
				ack.setTimeToComplete(60000);
				implementor.sendAck(ack);

				ngat.message.ISS_INST.MOVE_FOLD mf = new ngat.message.ISS_INST.MOVE_FOLD(
						request.getId());
				mf.setMirror_position(0);
				COMMAND_DONE mfdone = sendIssCommand(mf, 40000L);
				if (!(mfdone instanceof ngat.message.ISS_INST.MOVE_FOLD_DONE)) {
					if (implementor != null)
						implementor.sendDone(mfdone);
					return;
				}

				if (!mfdone.getSuccessful()) {
					MULTRUN_DONE done = new MULTRUN_DONE("");
					done.setErrorNum(100301);
					done.setErrorString("The move fold failed due to: "
							+ mfdone.getErrorString());
					done.setSuccessful(false);
					if (implementor != null)
						implementor.sendDone(done);
					return;
				}

				try {
					Thread.sleep(10000L);
				} catch (Exception e) {
				}

				FILENAME_ACK fack = new FILENAME_ACK("");
				fack.setTimeToComplete(10000);
				fack.setFilename("/icc/tmp/" + filePrefix + "_a_" + datestr
						+ "_" + (ilf) + "_1_1_0.fits");
				implementor.sendAck(fack);

				try {
					Thread.sleep(5000L);
				} catch (Exception e) {
				}

				FILENAME_ACK fpack = new FILENAME_ACK("");
				fpack.setTimeToComplete(10000);
				fpack.setFilename("/icc/tmp/" + filePrefix + "_a_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");
				implementor.sendAck(fpack);

				try {
					Thread.sleep(5000L);
				} catch (Exception e) {
				}

				ARC_DONE done = new ARC_DONE("");
				done.setFilename("icc/tmp/" + filePrefix + "_a_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");

				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof DARK) {
				ilf++;

				String datestr = fdf.format(new Date());

				int expose = ((DARK) request).getExposureTime();

				try {
					Thread.sleep(5000L + expose);
				} catch (Exception e) {
				}

				FILENAME_ACK fack = new FILENAME_ACK("");
				fack.setTimeToComplete(10000);
				fack.setFilename("/icc/tmp/" + filePrefix + "_d_" + datestr
						+ "_" + (ilf) + "_1_1_0.fits");
				implementor.sendAck(fack);

				try {
					Thread.sleep(2000L);
				} catch (Exception e) {
				}

				FILENAME_ACK fpack = new FILENAME_ACK("");
				fpack.setTimeToComplete(10000);
				fpack.setFilename("/icc/tmp/" + filePrefix + "_d_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");
				implementor.sendAck(fpack);

				try {
					Thread.sleep(3000L);
				} catch (Exception e) {
				}

				DARK_DONE done = new DARK_DONE("");
				done.setFilename("icc/tmp/" + filePrefix + "_d_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");

				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof FRODOSPEC_LAMPFLAT) {
				ilf++;

				String datestr = fdf.format(new Date());

				try {
					Thread.sleep(10000L);
				} catch (Exception e) {
				}

				int arm = ((FRODOSPEC_LAMPFLAT) request).getArm();
				String filePrefix = "";
				if (arm == FrodoSpecConfig.RED_ARM)
					filePrefix = "r";
				else
					filePrefix = "b";

				FILENAME_ACK fack = new FILENAME_ACK("");
				fack.setTimeToComplete(10000);
				fack.setFilename("/icc/tmp/" + filePrefix + "_l_" + datestr
						+ "_" + (ilf) + "_1_1_0.fits");
				implementor.sendAck(fack);

				try {
					Thread.sleep(5000L);
				} catch (Exception e) {
				}

				FILENAME_ACK fpack = new FILENAME_ACK("");
				fpack.setTimeToComplete(10000);
				fpack.setFilename("/icc/tmp/" + filePrefix + "_l_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");
				implementor.sendAck(fpack);

				try {
					Thread.sleep(5000L);
				} catch (Exception e) {
				}

				FRODOSPEC_LAMPFLAT_DONE done = new FRODOSPEC_LAMPFLAT_DONE("");
				done.setFilename("icc/tmp/" + filePrefix + "_l_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");

				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof FRODOSPEC_ARC) {
				ilf++;

				String datestr = fdf.format(new Date());

				try {
					Thread.sleep(10000L);
				} catch (Exception e) {
				}

				int arm = ((FRODOSPEC_ARC) request).getArm();
				String filePrefix = "";
				if (arm == FrodoSpecConfig.RED_ARM)
					filePrefix = "r";
				else
					filePrefix = "b";

				FILENAME_ACK fack = new FILENAME_ACK("");
				fack.setTimeToComplete(10000);
				fack.setFilename("/icc/tmp/" + filePrefix + "_a_" + datestr
						+ "_" + (ilf) + "_1_1_0.fits");
				implementor.sendAck(fack);

				try {
					Thread.sleep(5000L);
				} catch (Exception e) {
				}

				FILENAME_ACK fpack = new FILENAME_ACK("");
				fpack.setTimeToComplete(10000);
				fpack.setFilename("/icc/tmp/" + filePrefix + "_a_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");
				implementor.sendAck(fpack);

				try {
					Thread.sleep(5000L);
				} catch (Exception e) {
				}

				FRODOSPEC_ARC_DONE done = new FRODOSPEC_ARC_DONE("");
				done.setFilename("icc/tmp/" + filePrefix + "_a_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");

				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof FRODOSPEC_DARK) {
				ilf++;

				String datestr = fdf.format(new Date());

				try {
					Thread.sleep(10000L);
				} catch (Exception e) {
				}

				int arm = ((FRODOSPEC_DARK) request).getArm();
				String filePrefix = "";
				if (arm == FrodoSpecConfig.RED_ARM)
					filePrefix = "r";
				else
					filePrefix = "b";

				int expose = ((FRODOSPEC_DARK) request).getExposureTime();

				try {
					Thread.sleep(5000L + expose);
				} catch (Exception e) {
				}

				FILENAME_ACK fack = new FILENAME_ACK("");
				fack.setTimeToComplete(10000);
				fack.setFilename("/icc/tmp/" + filePrefix + "_d_" + datestr
						+ "_" + (ilf) + "_1_1_0.fits");
				implementor.sendAck(fack);

				try {
					Thread.sleep(2000L);
				} catch (Exception e) {
				}

				FILENAME_ACK fpack = new FILENAME_ACK("");
				fpack.setTimeToComplete(10000);
				fpack.setFilename("/icc/tmp/" + filePrefix + "_d_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");
				implementor.sendAck(fpack);

				try {
					Thread.sleep(3000L);
				} catch (Exception e) {
				}

				FRODOSPEC_DARK_DONE done = new FRODOSPEC_DARK_DONE("");
				done.setFilename("icc/tmp/" + filePrefix + "_d_" + datestr
						+ "_" + (ilf) + "_1_1_1.fits");

				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof TIMED_MULTRUNAT) {

				String datestr = fdf.format(new Date());

				int expose = ((TIMED_MULTRUNAT) request).getExposureTime();
				int duration = ((TIMED_MULTRUNAT) request).getTotalDuration();
				long runat = (((TIMED_MULTRUNAT) request).getStartTime())
						.getTime();

				// Send a MoveFold
				ack = new ACK("");
				ack.setTimeToComplete(60000);
				implementor.sendAck(ack);

				ngat.message.ISS_INST.MOVE_FOLD mf = new ngat.message.ISS_INST.MOVE_FOLD(
						request.getId());
				mf.setMirror_position(mirrorPort);
				COMMAND_DONE mfdone = sendIssCommand(mf, 40000L);
				if (!(mfdone instanceof ngat.message.ISS_INST.MOVE_FOLD_DONE)) {
					if (implementor != null)
						implementor.sendDone(mfdone);
					return;
				}

				if (!mfdone.getSuccessful()) {
					MULTRUN_DONE done = new MULTRUN_DONE("");
					done.setErrorNum(100301);
					done.setErrorString("The move fold failed due to: "
							+ mfdone.getErrorString());
					done.setSuccessful(false);
					if (implementor != null)
						implementor.sendDone(done);
					return;
				}

				ack = new ACK("");
				ack.setTimeToComplete(25000);
				implementor.sendAck(ack);

				// Send a _FITS to the ISS.
				GET_FITS getfits = new GET_FITS(request.getId());
				COMMAND_DONE done = sendIssCommand(getfits, 10000L);

				if (!(done instanceof GET_FITS_DONE)) {
					if (implementor != null)
						implementor.sendDone(done);
					return;
				}

				// wait for start unless weve passed it already
				long now = System.currentTimeMillis();
				if (now < runat) {
					System.err.println("Wait for runat time in: "
							+ ((runat - now) / 1000) + "s");

					ack = new ACK("");
					ack.setTimeToComplete((int) (runat - now) + 60000);
					implementor.sendAck(ack);

					try {
						Thread.sleep(runat - now);
					} catch (Exception e) {
					}
				} else {
					System.err
							.println("Passed runat time, starting exposure  immediately");
				}

				ack = new ACK("");
				ack.setTimeToComplete(duration + 60000);
				implementor.sendAck(ack);

				// now wait till the exposure is done...
				try {
					Thread.sleep(duration + 10000L);
				} catch (Exception e) {
				}

				// dump the fits
				int ixx = 0;
				TIMED_MULTRUNAT_DONE tdone = new TIMED_MULTRUNAT_DONE("");
				tdone.setFilename("/icc/tmp/" + filePrefix + "_e_" + datestr
						+ "_" + im + "_" + ixx + "_1_0.fits");
				double seeing = avSee + Math.random() * deltaSee - 0.5
						* deltaSee;
				tdone.setSeeing((float) seeing);
				tdone.setCounts(15000.0f);
				tdone.setXpix(666.0f);
				tdone.setYpix(555.0f);
				tdone.setPhotometricity(0.5f);
				tdone.setSkyBrightness(23.0f);
				tdone.setSaturation(false);
				reply = tdone;
				reply.setSuccessful(true);

			} else if (request instanceof TELFOCUS) {

				double startFocus = (double) (((TELFOCUS) request)
						.getStartFocus());
				double endFocus = (double) (((TELFOCUS) request).getEndFocus());
				double step = (double) (((TELFOCUS) request).getStep());
				double exposureTime = (double) (((TELFOCUS) request)
						.getExposureTime());

				// work out what we will use for the optimum focus value
				// somewhere near the centre of the range.
				double focus0 = 0.5 * (endFocus + startFocus) + 0.2
						* (Math.random() - 0.5) * (endFocus - startFocus);

				// more model parameters
				double mk = 3.0 + Math.random() * 3.0; // scaling factor. (3, 6)
				double mw0 = 0.2 + Math.random() * 0.6; // fwhm at optimal.
														// (0.2, 0.8)
				double mff = (endFocus - startFocus) / 2.0; // half focus range.

				// what are the a,b,c quadratic parameters ?
				double aa = mk * mw0 / (mff * mff);
				double bb = -2.0 * aa * focus0;
				double cc = aa * focus0 * focus0 + mw0;

				// Send a setfocus
				ack = new ACK("");
				ack.setTimeToComplete(120000);
				implementor.sendAck(ack);

				int ix = 0;
				double focus = startFocus;
				while (focus < endFocus) {
					// new ack...
					ack = new ACK("");
					ack.setTimeToComplete(25000 + (int) exposureTime);
					implementor.sendAck(ack);

					ngat.message.ISS_INST.SET_FOCUS setfocus = new ngat.message.ISS_INST.SET_FOCUS(
							request.getId());
					setfocus.setFocus((float) focus);

					COMMAND_DONE sfdone = sendIssCommand(setfocus, 40000L);
					if (!(sfdone instanceof ngat.message.ISS_INST.SET_FOCUS_DONE)) {
						if (implementor != null)
							implementor.sendDone(sfdone);
						return;
					}

					if (!sfdone.getSuccessful()) {
						TELFOCUS_DONE done = new TELFOCUS_DONE("");
						done.setErrorNum(102001); // this may be wrong code ?
						done.setErrorString("The telfocus failed due to: "
								+ sfdone.getErrorString());
						done.setSuccessful(false);
						if (implementor != null)
							implementor.sendDone(done);
						return;
					}

					// Telfocus Ack
					try {
						Thread.sleep(3000 + (long) exposureTime);
					} catch (Exception e) {
					}

					TELFOCUS_ACK tack = new TELFOCUS_ACK("");
					tack.setTimeToComplete(30000 + (int) exposureTime);
					tack.setFilename("/icc/tmp/telfocus_" + ix + "_0.fits");
					implementor.sendAck(tack);

					ix++;

					focus += step;
				}

				// now process the files and generate results...
				ix = 0;
				focus = startFocus;
				double chi2 = 0.0;
				while (focus < endFocus) {
					ack = new ACK("");
					ack.setTimeToComplete(30000);
					implementor.sendAck(ack);

					TELFOCUS_DP_ACK tdack = new TELFOCUS_DP_ACK("");
					tdack.setTimeToComplete(30000);
					tdack.setFilename("/icc/tmp/telfocus_" + ix + "_1.fits");

					// calculate the seeing at focus plus random noise
					double err = 0.4 * (Math.random() - 0.5);
					double seeing = aa * focus * focus + bb * focus + cc + err;
					chi2 += err * err;
					tdack.setSeeing((float) seeing);
					implementor.sendAck(tdack);
					try {
						Thread.sleep(2000L);
					} catch (Exception e) {
					}

					ix++;
					focus += step;
				}

				// set optimum focus now...
				ngat.message.ISS_INST.SET_FOCUS setfocus = new ngat.message.ISS_INST.SET_FOCUS(
						request.getId());
				setfocus.setFocus((float) focus0);

				COMMAND_DONE sfdone = sendIssCommand(setfocus, 40000L);
				if (!(sfdone instanceof ngat.message.ISS_INST.SET_FOCUS_DONE)) {
					if (implementor != null)
						implementor.sendDone(sfdone);
					return;
				}

				if (!sfdone.getSuccessful()) {
					TELFOCUS_DONE done = new TELFOCUS_DONE("");
					done.setErrorNum(102001); // this may be wrong code ?
					done.setErrorString("The telfocus failed due to: "
							+ sfdone.getErrorString());
					done.setSuccessful(false);
					if (implementor != null)
						implementor.sendDone(done);
					return;
				}

				// At last the final reply...
				TELFOCUS_DONE done = new TELFOCUS_DONE("");

				done.setA(aa);
				done.setB(bb);
				done.setC(cc);
				done.setSeeing((float) mw0);
				done.setChiSquared(chi2);
				done.setCurrentFocus((float) focus0);
				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof MULTRUN) {
				String datestr = fdf.format(new Date());

				int expose = ((MULTRUN) request).getExposureTime();
				int number = ((MULTRUN) request).getNumberExposures();

				boolean durationExposure = false;

				// number = 0 MEANS a DURATION exposure, overall time is
				// exposure time.
				// we will not ACK or DPACK
				if (number == 0) {
					number = (int) Math.floor(expose / 6000) + 1;
					expose = 6000;
					durationExposure = true;
				}

				// Send a MoveFold
				ack = new ACK("");
				ack.setTimeToComplete(60000);
				implementor.sendAck(ack);

				ngat.message.ISS_INST.MOVE_FOLD mf = new ngat.message.ISS_INST.MOVE_FOLD(
						request.getId());
				mf.setMirror_position(mirrorPort);
				COMMAND_DONE mfdone = sendIssCommand(mf, 40000L);
				if (!(mfdone instanceof ngat.message.ISS_INST.MOVE_FOLD_DONE)) {
					if (implementor != null)
						implementor.sendDone(mfdone);
					return;
				}

				if (!mfdone.getSuccessful()) {
					MULTRUN_DONE done = new MULTRUN_DONE("");
					done.setErrorNum(100301);
					done.setErrorString("The move fold failed due to: "
							+ mfdone.getErrorString());
					done.setSuccessful(false);
					if (implementor != null)
						implementor.sendDone(done);
					return;
				}

				// Send an AutoGuide on..

				AG_START agstart = new AG_START(request.getId());
				COMMAND_DONE agdone = sendIssCommand(agstart, 40000L);
				if (!(agdone instanceof AG_START_DONE)) {
					if (implementor != null)
						implementor.sendDone(agdone);
					return;
				}

				im++;
				int ixx = 0;
				for (int ix = 0; ix < number; ix++) {
					ack = new ACK("");
					ack.setTimeToComplete(25000 + expose);
					implementor.sendAck(ack);

					// Send a GET_FITS to the ISS.
					GET_FITS getfits = new GET_FITS(request.getId());
					COMMAND_DONE done = sendIssCommand(getfits, 10000L);

					if (!(done instanceof GET_FITS_DONE)) {
						if (implementor != null)
							implementor.sendDone(done);
						return;
					}

					GET_FITS_DONE getfitsdone = (GET_FITS_DONE) done;
					// print the fits headers out...
					Vector v = getfitsdone.getFitsHeader();
					Iterator ih = v.iterator();
					while (ih.hasNext()) {
						FitsHeaderCardImage fits = (FitsHeaderCardImage) ih
								.next();
						System.err.println("FITS [" + fits.toString() + "]");
						// fall over with null headers
						if (fits.getValue() == null) {
							System.err.println("NULL Header: "
									+ fits.getKeyword());
							done.setSuccessful(false);
							done.setErrorNum(100999);
							done.setErrorString("Null header for: "
									+ fits.getKeyword());
							if (implementor != null)
								implementor.sendDone(done);
							return;
						}
					}

					try {
						Thread.sleep(3000 + expose);
					} catch (Exception e) {
					}

					String affix = "_e_";
					if (((MULTRUN) request).getStandard())
						affix = "_s_";

					if (!durationExposure) {
						MULTRUN_ACK mack = new MULTRUN_ACK("");
						mack.setTimeToComplete(30000 + expose);
						mack.setFilename("/icc/tmp/" + filePrefix + affix
								+ datestr + "_" + (im) + "_" + ix + "_1_0.fits");
						implementor.sendAck(mack);
					}

					// dump the fits
					try {
						File file = new File("/icc/tmp/" + filePrefix + affix
								+ datestr + "_" + im + "_" + ixx + "_1_0.fits");
						PrintStream pout = new PrintStream(
								new FileOutputStream(file));
						ih = v.iterator();
						while (ih.hasNext()) {
							FitsHeaderCardImage fits = (FitsHeaderCardImage) ih
									.next();
							if (fits.getValue() == null) {
								System.err.println("NULL Header: "
										+ fits.getKeyword());
							} else {
								pout.println("FITS [" + fits.toString() + "]");
							}
						}
						pout.close();
					} catch (Exception e) {
						e.printStackTrace();
					}
					ixx++;
				}

				// Send an AutoGuide off..

				AG_STOP agstop = new AG_STOP(request.getId());
				COMMAND_DONE agtstopdone = sendIssCommand(agstop, 40000L);

				String affix = "_e_";
				if (((MULTRUN) request).getStandard())
					affix = "_s_";

				ixx = 0;
				for (int ix = 0; ix < number; ix++) {
					ack = new ACK("");
					ack.setTimeToComplete(30000 + expose);
					implementor.sendAck(ack);

					if (!durationExposure) {
						MULTRUN_DP_ACK mdack = new MULTRUN_DP_ACK("");
						mdack.setTimeToComplete(30000 + expose);

						mdack.setFilename("/icc/tmp/" + filePrefix + affix
								+ datestr + "_" + (im) + "_" + ix + "_1_1.fits");
						double seeing = avSee + Math.random() * deltaSee - 0.5
								* deltaSee;
						mdack.setSeeing((float) seeing);
						implementor.sendAck(mdack);
						try {
							Thread.sleep(2000L);
						} catch (Exception e) {
						}
					}
					ixx++;
				}

				MULTRUN_DONE done = new MULTRUN_DONE("");
				done.setFilename("/icc/tmp/" + filePrefix + affix + datestr
						+ "_" + im + "_" + ixx + "_1_0.fits");
				double seeing = avSee + Math.random() * deltaSee - 0.5
						* deltaSee;
				done.setSeeing((float) seeing);
				done.setCounts(15000.0f);
				done.setXpix(666.0f);
				done.setYpix(555.0f);
				done.setPhotometricity(0.5f);
				done.setSkyBrightness(23.0f);
				done.setSaturation(false);
				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof FRODOSPEC_MULTRUN) {

				String datestr = fdf.format(new Date());

				int expose = ((FRODOSPEC_MULTRUN) request).getExposureTime();
				int number = ((FRODOSPEC_MULTRUN) request).getNumberExposures();

				int arm = ((FRODOSPEC_MULTRUN) request).getArm();

				if (System.getProperty("dilate") != null) {

					int factor = 10;
					try {
						factor = Integer.parseInt(System.getProperty("dilate"));
					} catch (Exception e) {
					}
					expose = expose / factor;
					System.err.println("Exposure: Using dilation factor: "
							+ factor + " Expose-> " + expose);
				}

				// Send a MoveFold
				ack = new ACK("");
				ack.setTimeToComplete(60000);
				implementor.sendAck(ack);

				ngat.message.ISS_INST.MOVE_FOLD mf = new ngat.message.ISS_INST.MOVE_FOLD(
						request.getId());
				mf.setMirror_position(mirrorPort);
				COMMAND_DONE mfdone = sendIssCommand(mf, 40000L);
				if (!(mfdone instanceof ngat.message.ISS_INST.MOVE_FOLD_DONE)) {
					if (implementor != null)
						implementor.sendDone(mfdone);
					return;
				}

				if (!mfdone.getSuccessful()) {
					FRODOSPEC_MULTRUN_DONE done = new FRODOSPEC_MULTRUN_DONE("");
					done.setErrorNum(100301);
					done.setErrorString("The move fold failed due to: "
							+ mfdone.getErrorString());
					done.setSuccessful(false);
					if (implementor != null)
						implementor.sendDone(done);
					return;
				}

				// Send an AutoGuide on..

				AG_START agstart = new AG_START(request.getId());
				COMMAND_DONE agdone = sendIssCommand(agstart, 40000L);
				if (!(agdone instanceof AG_START_DONE)) {
					if (implementor != null)
						implementor.sendDone(agdone);
					return;
				}

				im++;
				int ixx = 0;
				for (int ix = 0; ix < number; ix++) {
					ack = new ACK("");
					ack.setTimeToComplete(25000 + expose);
					implementor.sendAck(ack);

					// Send a GET_FITS to the ISS.
					GET_FITS getfits = new GET_FITS(request.getId());
					COMMAND_DONE done = sendIssCommand(getfits, 10000L);

					if (!(done instanceof GET_FITS_DONE)) {
						if (implementor != null)
							implementor.sendDone(done);
						return;
					}

					GET_FITS_DONE getfitsdone = (GET_FITS_DONE) done;
					// print the fits headers out...
					Vector v = getfitsdone.getFitsHeader();
					Iterator ih = v.iterator();
					while (ih.hasNext()) {
						FitsHeaderCardImage fits = (FitsHeaderCardImage) ih
								.next();
						System.err.println("FITS [" + fits.toString() + "]");

						// fall over with null headers
						if (fits.getValue() == null) {
							System.err.println("NULL Header: "
									+ fits.getKeyword());
							done.setSuccessful(false);
							done.setErrorNum(100999);
							done.setErrorString("Null header for: "
									+ fits.getKeyword());
							if (implementor != null)
								implementor.sendDone(done);
							return;
						}

					}

					try {
						Thread.sleep(3000 + expose);
					} catch (Exception e) {
					}

					MULTRUN_ACK mack = new MULTRUN_ACK("");
					mack.setTimeToComplete(30000 + expose);
					if (arm == FrodoSpecConfig.RED_ARM)
						mack.setFilename("/icc/tmp/r_e_" + datestr + "_" + (im)
								+ "_" + ix + "_1_0.fits");
					else
						mack.setFilename("/icc/tmp/b_e_" + datestr + "_" + (im)
								+ "_" + ix + "_1_0.fits");
					implementor.sendAck(mack);

					// dump the fits
					if (arm == FrodoSpecConfig.RED_ARM)
						filePrefix = "r";
					else
						filePrefix = "b";
					try {
						File file = new File("/icc/tmp/" + filePrefix + "_e_"
								+ datestr + "_" + im + "_" + ixx + "_1_0.fits");
						PrintStream pout = new PrintStream(
								new FileOutputStream(file));
						ih = v.iterator();
						while (ih.hasNext()) {
							FitsHeaderCardImage fits = (FitsHeaderCardImage) ih
									.next();
							if (fits.getValue() == null) {
								System.err.println("NULL Header: "
										+ fits.getKeyword());
							} else {
								pout.println("FITS [" + fits.toString() + "]");
							}
						}
						pout.close();
					} catch (Exception e) {
						e.printStackTrace();
					}
					ixx++;
				}

				// Send an AutoGuide off..

				AG_STOP agstop = new AG_STOP(request.getId());
				COMMAND_DONE agtstopdone = sendIssCommand(agstop, 40000L);

				ixx = 0;
				for (int ix = 0; ix < number; ix++) {
					ack = new ACK("");
					ack.setTimeToComplete(30000 + expose);
					implementor.sendAck(ack);

					MULTRUN_DP_ACK mdack = new MULTRUN_DP_ACK("");
					mdack.setTimeToComplete(30000 + expose);
					if (arm == FrodoSpecConfig.RED_ARM)
						mdack.setFilename("/icc/tmp/r_e_" + datestr + "_"
								+ (im) + "_" + ix + "_1_1.fits");
					else
						mdack.setFilename("/icc/tmp/b_e_" + datestr + "_"
								+ (im) + "_" + ix + "_1_1.fits");
					double seeing = avSee + Math.random() * deltaSee - 0.5
							* deltaSee;
					mdack.setSeeing((float) seeing);
					implementor.sendAck(mdack);
					try {
						Thread.sleep(2000L);
					} catch (Exception e) {
					}
					ixx++;
				}

				FRODOSPEC_MULTRUN_DONE done = new FRODOSPEC_MULTRUN_DONE("");
				if (arm == FrodoSpecConfig.RED_ARM)
					done.setFilename("icc/tmp/r_e_" + datestr + "_" + (im)
							+ "_" + ixx + "_1_0.fits");
				else
					done.setFilename("icc/tmp/b_e_" + datestr + "_" + (im)
							+ "_" + ixx + "_1_0.fits");

				double seeing = avSee + Math.random() * deltaSee - 0.5
						* deltaSee;
				done.setSeeing((float) seeing);
				done.setCounts(15000.0f);
				done.setXpix(666.0f);
				done.setYpix(555.0f);
				done.setPhotometricity(0.5f);
				done.setSkyBrightness(23.0f);
				done.setSaturation(false);
				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof TWILIGHT_CALIBRATE) {

				// TODO Sort this sequence out later, for now just wait a while

				ack = new ACK("");
				ack.setTimeToComplete(60000);
				implementor.sendAck(ack);

				int ixx = 0;
				for (int ix = 0; ix < 8; ix++) {
					ixx++;
					TWILIGHT_CALIBRATE_ACK twack = new TWILIGHT_CALIBRATE_ACK(
							"");
					twack.setTimeToComplete(60000);
					twack.setFilename("/icc/tmp/skyflat" + ix + ".fits");
					implementor.sendAck(twack);
					try {
						Thread.sleep(30000L);
					} catch (Exception e) {
					}
				}

				TWILIGHT_CALIBRATE_DONE done = new TWILIGHT_CALIBRATE_DONE("");
				done.setFilename("/icc/tmp/skyflat" + ixx + ".fits");
				done.setMeanCounts((float) (Math.random() * 10000.0));
				done.setPeakCounts((float) (Math.random() * 10000.0));
				reply = done;
				reply.setSuccessful(true);

			} else if (request instanceof GET_STATUS) {
				GET_STATUS_DONE done = new GET_STATUS_DONE("");
				done.setCurrentMode(GET_STATUS_DONE.MODE_IDLE);

				// read any new status from a file which operator can change at
				// will
				Properties props = new Properties();
				try {
					props.load(new FileInputStream(name.toLowerCase()
							+ ".status")); // e.g. ratcam.status
				} catch (Exception e) {
					// dont really care
				}
				status = new Hashtable(props);
				// replace temperature from a model
				status.put("Temperature", new Double(Math.random() * 50.0));
				status.put("Heater ADU", new Double(
						Math.random() * 50.0 + 2500.0));

				if (name.equals("FRODO")) {
					status.put("red.Temperature",
							new Double(20.0 + Math.random() * 5.0));
					status.put("red.Heater ADU", new Double(
							Math.random() * 50.0 + 2500.0));
					status.put("blue.Temperature",
							new Double(40.0 + Math.random() * 5.0));
					status.put("blue.Heater ADU", new Double(
							Math.random() * 50.0 + 2500.0));
					status.put("Environment.Temperature.0", ""
							+ (Math.random() * 50.0)); // bizzarely a string
					status.put("Environment.Temperature.2", ""
							+ (Math.random() * 50.0)); // bizzarely a string
				} else if (name.equals("RINGO3")) {
					status.put("Temperature.0.0",
							new Double(10.0 + Math.random() * 2.0));
					status.put("Temperature.1.0",
							new Double(15.0 + Math.random() * 2.0));
					status.put("Temperature.1.1",
							new Double(20.0 + Math.random() * 2.0));
				}

				done.setDisplayInfo(status);
				reply = done;
				reply.setSuccessful(true);
			} else {
				reply = new COMMAND_DONE("");
				reply.setSuccessful(false);
				reply.setErrorNum(666);
				reply.setErrorString("Unknown command class: "
						+ request.getClass());
			}

			if (implementor != null)
				implementor.sendDone(reply);

		}

		/**
		 * Sends an ISS command. This call will block for timeout.
		 * 
		 * @return The reply to the command.
		 */
		private COMMAND_DONE sendIssCommand(COMMAND command, long timeout) {
			System.err.println("SendIssCommand: Sending: " + command);

			IConnection issConnect = new SocketConnection(issHost, issPort);
			IssHandler handler = new IssHandler(command, timeout);
			JMSMA_ProtocolClientImpl impl = new JMSMA_ProtocolClientImpl(
					handler, issConnect);

			impl.implement();

			return handler.getDone();

		}

		/**
		 * Implementors should provide an indication of the expected execution
		 * time of the handleRequest() method in msecs.
		 */
		public long getHandlingTime() {
			return 60000L;
		}

		/** Called to allow the handler to release resources before disposal. */
		public void dispose() {
			// System.err.println("** WARNIN // TODO Dispose handler");
		}

		/** Called if an Exception is thrown by another thread. */
		public void exceptionOccurred(Object source, Exception e) {
			System.err.println("**ERROR: " + source + " : " + e);
		}

	}

	class IssHandler extends JMSMA_ClientImpl {

		private COMMAND_DONE done;

		IssHandler(COMMAND command, long timeout) {
			super();
			this.command = command;
			this.timeout = timeout;
		}

		public void failedConnect(Exception e) {
			e.printStackTrace();
			done = failed(7501, "Failed to connect to ISS@" + issHost + ":"
					+ issPort + " for command: " + command);
		}

		public void failedDespatch(Exception e) {
			e.printStackTrace();
			done = failed(7502, "Failed to despatch command: " + command);
		}

		public void failedResponse(Exception e) {
			System.err.println("ICS: Failed response to command: " + command);
			e.printStackTrace();
			done = failed(7503, "Failed to receive reply");
		}

		public void exceptionOccurred(Object source, Exception e) {
			System.err.println("ICS: exceptionOccurred: " + source + " : " + e);
			e.printStackTrace();
			done = failed(7504, "Exception occurred " + source + " : " + e);
		}

		public void handleAck(ACK ack) {
			System.err.println("ICS: Ack:" + ack + " to="
					+ ack.getTimeToComplete());
		}

		public void handleDone(COMMAND_DONE done) {
			System.err.println("ICS: Done: " + done);
			this.done = done;
		}

		public void sendCommand(COMMAND command) {
		}

		public COMMAND_DONE getDone() {
			return done;
		}

		private COMMAND_DONE failed(int code, String msg) {
			COMMAND_DONE done = new COMMAND_DONE("Fail");
			done.setSuccessful(false);
			done.setErrorNum(code);
			done.setErrorString(msg);
			return done;
		}

	}

}
